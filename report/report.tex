\documentclass{article}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{amsmath} % For math symbols

\begin{document}
\title{INF421 PI\@: PATH PLANNING ALGORITHMS}
\author{Merouane Benadda, Antoine FÃ¨vre}

\maketitle

\textbf{Question 1.} We chose to implement the algorithm in C++, as it allows better performance. 
For visualization, we used Python with Matplotlib, as it provides a more convenient way to create visual representations of the results.

\medskip

\textbf{Question 2.} See the implementation in the file \texttt{scripts/visualize.py}.

\medskip

\textbf{Question 3.} See the implementation in the file \texttt{src/pso.cpp}.

\medskip

\textbf{Question 4.} See the implementation in the file \texttt{src/pso.cpp}.

\medskip

\textbf{Question 5.} 

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

    \Input{Problem scenario $P$, iterations $I$, constants $c_1, c_2, w$}
    \Output{Global best path $g_{best}$ and its cost $f(g_{best})$}

    \BlankLine
    Initialize $g_{best}$ with the first particle's waypoints\;
    \For{$iter = 1$ \KwTo$I$}{
        \BlankLine
        \tcp{Evaluate Fitness and Update Memory}
        \ForEach{particle $p$ in swarm}{
            $cost \leftarrow \text{fitness}(p.waypoints, P)$\;
            
            \If{$cost < p.best\_cost$}{
                $p.best\_cost \leftarrow cost$\;
                $p.best\_waypoints \leftarrow p.waypoints$\;
            }
            
            \If{$cost < g_{best}.cost$}{
                $g_{best}.cost \leftarrow cost$\;
                $g_{best}.waypoints \leftarrow p.waypoints$\;
            }
        }

        \BlankLine
        \tcp{Update Kinematics}
        \ForEach{particle $p$ in swarm}{
            \For{each waypoint $i$ in path}{
                $r_1, r_2 \leftarrow \text{random}(0, 1)$\;
                
                \tcp{Velocity Update}
                $v_i \leftarrow w \cdot v_i + c_1 \cdot r_1 \cdot (p.best\_waypoints_i - p.waypoints_i) + c_2 \cdot r_2 \cdot (g_{best}.waypoints_i - p.waypoints_i)$\;
                
                \tcp{Position Update}
                $p.waypoints_i \leftarrow p.waypoints_i + v_i$\;
                
                \tcp{Boundary Constraint}
                $p.waypoints_i \leftarrow \text{clamp}(p.waypoints_i, P.\min, P.\max)$\;
            }
        }
    }
    \Return{$g_{best}$}
    \caption{Particle Swarm Optimization for Path Planning}\label{alg:pso}
\end{algorithm}

\medskip

\textbf{Question 6.} The complexity of the algorithm is $O(I \cdot N \cdot M)$, where $I$ is the number of iterations, $N$ is the number of particles in the swarm, and $M$ is the number of waypoints in each particle's path. 

Indeed, for each iteration, we evaluate the fitness of each particle, which takes $O(N \cdot M)$ time, since we compute the fitness by iterating over each waypoint in each particle's path. Then, we update the velocity and position of each particle, which also takes $O(N \cdot M)$ time, as we need to update each waypoint for each particle. Therefore, the overall complexity is $O(I \cdot N \cdot M)$.

\medskip

\textbf{Question 7.} See the implementation in the file \texttt{src/pso.cpp}.

\medskip

\textbf{Question 8.}

\textbf{Scenario 0}

\textbf{Scenario 1}


\textbf{Scenario 2}

\textbf{Scenario 3}

\textbf{Scenario 4}



\medskip

\textbf{Question 9.}

\medskip

\textbf{Question 10.}

\medskip

\textbf{Question 11.}

\medskip

\textbf{Question 12.} To improve the performance of the algorithm, we could refine the fitness function. Instead of simply being the euclidian distance plus infinity if the path crosses an obstacle, we can make it output the euclidian distance plus a penalty proportional to the distance crossed in the obstacles.

This way, the algorithm would converge faster, especially in cases with lots of obstacles, as it would be able to differentiate between paths that are close to the optimal one but cross an obstacle and paths that are far from the optimal one but do not cross any obstacle.

To do so, we compute the intersection of the path with the obstacles in \texttt{src/utils.cpp}. To avoid any situation where the alogorithm would prefer crossing an obstacle to reduce the distance, we can set the penalty to be a large constant multiplied by the distance crossed in the obstacle.

\medskip

\textbf{Question 13.}

\medskip

\textbf{Question 14.}

\medskip

\textbf{Question 15.}

\medskip

\textbf{Question 16.}

\medskip

\textbf{Question 17.}

\medskip

\textbf{Question 18.}

\medskip

\textbf{Question 19.}

\medskip

\textbf{Question 20.}

\medskip

\textbf{Question 21.}

\medskip

\textbf{Question 22.}

\medskip

\textbf{Question 23.}

\medskip

\textbf{Question 24.}

\medskip

\textbf{Question 25.} We use Github for version control and to share our code. It is a very convenient tool for collaboration, as it allows us to easily track changes, manage branches, and review each other's code.

We also used GitHub Copilot to help us with some of the redundant code, such as the verification of the input or the geometry functions. It is a very useful tool for increasing productivity, as it can generate code snippets based on the context, which saves us time and allows us to focus on the more complex parts of the implementation. However, we used it very carefully, as it can sometimes generate incorrect code, so we always reviewed the generated code line by line to ensure its correctness.

\medskip

\end{document}